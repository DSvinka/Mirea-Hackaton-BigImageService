<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Canvas Tile Viewer</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
        }

        #controls {
            position: fixed;
            top: 10px;
            left: 10px;
            z-index: 100;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            color: white;
        }

        button {
            background-color: #333;
            color: white;
            border: 1px solid #555;
            padding: 5px 10px;
            margin: 5px;
            cursor: pointer;
        }

        button:hover {
            background-color: #555;
        }
    </style>
</head>
<body>
<canvas id="viewer"></canvas>

<div id="controls">
    <button id="zoomIn">Увеличить</button>
    <button id="zoomOut">Уменьшить</button>
    <button id="reset">Сбросить</button>
    <span>Масштаб: <span id="scale">1</span></span>
</div>

<script>
async function init() {
    const image_name = "bio_cut"

    const response = await fetch(`http://localhost:8000/info/${image_name}`, {method: "GET", headers: {"Content-Type": "application/json"}})
    if (!response.ok) {
        throw new Error(`Response status: ${response.status}`);
    }

    const result = await response.json()

    const canvas = document.getElementById('viewer');
    const ctx = canvas.getContext('2d');
    const zoomInButton = document.getElementById('zoomIn');
    const zoomOutButton = document.getElementById('zoomOut');
    const resetButton = document.getElementById('reset');
    const scaleText = document.getElementById('scale');

    ctx.imageSmoothingEnabled = false;

    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    const tileSize = 2048;
    const buffer = 1; // Количество тайлов за пределами экрана
    const imageWidth = result.size[0]; // Ширина изображения
    const imageHeight = result.size[1]; // Высота изображения

    let scale = 0.1; // Начальный масштаб
    let tileScale = 5;
    let offsetX = 0;
    let offsetY = 0;
    let isDragging = false;
    let startX, startY;

    const tiles = {}; // Кэш для тайлов

    // Загрузка тайла
    function loadTile(row, col) {
        const tileKey = `${row}_${col}`;
        if (tiles[tileKey] && tiles[tileKey].scale === tileScale) return tiles[tileKey];

        const img = new Image();
        img.src = `http://127.0.0.1:8000/tiles/bio_cut/${tileScale}/${row * tileSize}_${col * tileSize}.png`;

        tiles[tileKey] = {img: img, scale: tileScale};
        return tiles[tileKey];
    }

    // Отображение видимых тайлов
    function renderTiles() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        const startCol = Math.floor((-offsetX - canvas.width * buffer) / (tileSize * scale));
        const endCol = Math.ceil((-offsetX + canvas.width * (1 + buffer)) / (tileSize * scale));
        const startRow = Math.floor((-offsetY - canvas.height * buffer) / (tileSize * scale));
        const endRow = Math.ceil((-offsetY + canvas.height * (1 + buffer)) / (tileSize * scale));

        try {
            for (let row = startRow; row <= endRow; row++) {
                for (let col = startCol; col <= endCol; col++) {
                    if (
                        row < 0 || col < 0 ||
                        row * tileSize >= imageWidth ||
                        col * tileSize >= imageHeight
                    ) continue;

                    const img = loadTile(row, col).img;
                    const x = Math.round(offsetX + col * tileSize * scale);
                    const y = Math.round(offsetY + row * tileSize * scale);
                    const size = Math.round(tileSize * scale);

                    if (img.complete) {
                        ctx.drawImage(img, x - 1, y - 1, size + 2, size + 2);
                    } else {
                        img.onload = () => ctx.drawImage(img, x - 1, y - 1, size + 2, size + 2);
                    }
                }
            }
        }
        catch (error) {
            console.log(error);
        }
    }

    // Масштабирование
    function zoom(factor, mouseX, mouseY) {
        const newScale = scale * factor;
        offsetX = mouseX - (mouseX - offsetX) * (newScale / scale);
        offsetY = mouseY - (mouseY - offsetY) * (newScale / scale);
        scale = newScale;
        scaleText.textContent = `${(scale * 100).toFixed(2)} (${tileScale})`;

        if (scale*100 > 30) {
            tileScale = 0;
        }
        else if (scale*100 > 20) {
            tileScale = 2;
        }
        else {
            tileScale = 5
        }

        renderTiles();
    }

    // События
    canvas.addEventListener('mousedown', (e) => {
        isDragging = true;
        startX = e.clientX;
        startY = e.clientY;
    });

    canvas.addEventListener('mousemove', (e) => {
        if (!isDragging) return;

        const dx = e.clientX - startX;
        const dy = e.clientY - startY;

        offsetX += dx;
        offsetY += dy;

        startX = e.clientX;
        startY = e.clientY;

        renderTiles();
    });

    canvas.addEventListener('mouseup', () => {
        isDragging = false;
    });

    canvas.addEventListener('mouseleave', () => {
        isDragging = false;
    });

    canvas.addEventListener('wheel', (e) => {
        e.preventDefault();

        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;

        const factor = e.deltaY < 0 ? 1.1 : 0.9;
        zoom(factor, mouseX, mouseY);
    });

    zoomInButton.addEventListener('click', () => {
        zoom(1.2, canvas.width / 2, canvas.height / 2);
    });

    zoomOutButton.addEventListener('click', () => {
        zoom(0.8, canvas.width / 2, canvas.height / 2);
    });

    resetButton.addEventListener('click', () => {
        offsetX = 0;
        offsetY = 0;
        scale = 1;
        renderTiles();
    });

    // Инициализация
    renderTiles();

    // Обновление размеров Canvas при изменении окна
    window.addEventListener('resize', () => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        renderTiles();
    });
}

init()
</script>
</body>
</html>
